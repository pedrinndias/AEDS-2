
## NESTA SESSÃO

O desenvolvimento de algoritmos envolve um processo composto por sete etapas. Primeiramente, é necessário compreender o problema, identificando suas entradas, saídas, restrições e requisitos. Em seguida, definimos o problema em termos computacionais, traduzindo-o do mundo real para algo que um algoritmo possa resolver. A terceira etapa consiste no projeto do algoritmo, na qual escolhemos técnicas apropriadas, considerando critérios como custo, desempenho e corretude. Analisamos então a eficiência do algoritmo, levando em conta diferentes casos, como o melhor caso, o pior caso e o caso médio, e avaliando fatores como tempo de execução e uso de recursos. Essa análise pode ser realizada por meio de técnicas matemáticas, como a notação assintótica e a resolução de recorrências. Em seguida, partimos para a implementação do algoritmo em uma linguagem de programação específica. Testamos e depuramos o algoritmo para verificar se produz os resultados esperados para diferentes conjuntos de dados de entrada. Por fim, realizamos a etapa de manutenção, na qual fazemos melhorias, ajustes de requisitos e otimizações visando aprimorar o desempenho do algoritmo ao longo do tempo.

O projeto de algoritmos desempenha um papel fundamental na resolução eficiente de problemas computacionais. Um bom projeto de algoritmos permite obter soluções mais rápidas, economizar recursos e melhorar o desempenho dos sistemas. Por outro lado, um projeto inadequado pode resultar em soluções ineficientes, consumindo tempo e recursos desnecessários. É importante destacar que algoritmos eficientes possuem características específicas que garantem seu desempenho e utilidade. Em primeiro lugar, a corretude é essencial, ou seja, o algoritmo deve produzir a saída correta para todas as entradas válidas. Além disso, a eficiência é crucial, garantindo que o algoritmo execute em tempo hábil e utilize o mínimo de recursos necessários. A escalabilidade também é uma característica importante, permitindo que o algoritmo mantenha sua eficiência mesmo com o aumento do tamanho da entrada. Por fim, a estrutura do algoritmo deve ser organizada e modular, facilitando sua compreensão e manutenção ao longo do tempo. Ao levar em consideração essas características, é possível projetar algoritmos que atendam aos requisitos de desempenho e qualidade, proporcionando soluções eficientes e duradouras.

O restante desta sessão de estudos apresenta uma revisão sobre conceitos básicos sobre algoritmos em grafos e, em seguida, aborda as técnicas de força bruta e divisão e conquista. As demais técnicas de projeto são abordadas na sessão de estudo subsequente. A última sessão de estudos desta unidade apresenta a teoria da complexidade.

---

**REVISÃO DE ALGUNS CONCEITOS BÁSICOS DE ALGORITMOS EM GRAFOS**

Os algoritmos em grafos são uma ferramenta poderosa na área da Computação. Um grafo consiste em uma coleção de vértices e arestas, onde os vértices podem ter nomes e outros atributos. As arestas representam as conexões entre dois vértices. Uma aresta pode ter peso que representa o custo para sair de um vértice até o outro. Por definição, um grafo deve ter pelo menos um vértice. As Figuras 1 e 2 apresentam dois exemplos de grafos sendo que o primeiro é um grafo não orientado ou não direcionado dado que suas arestas não apresentam direção. O segundo exemplo é um dígrafo (grafo orientado ou direcionado) porque suas arestas são associadas a pares ordenados de vértices. Por exemplo, na Figura 1, o peso da aresta entre os vértices 3 e 6 é um. Na Figura 2, o peso da aresta (3, 6) é um e o da aresta (6, 3) é zero porque não existe tal aresta. Algumas das principais aplicações dos grafos incluem: redes sociais e análise de mídias sociais, onde os grafos são usados para identificar comunidades, influenciadores e padrões de propagação de informações. Na área de logística e roteamento, os grafos podem ser usados para otimizar a distribuição de recursos e o planejamento de rotas. A bioinformática utiliza grafos para modelar interações moleculares, redes de proteínas e análise de sequências genéticas. Em redes de computadores, os grafos são aplicados para projetar e otimizar redes de comunicação, redes de transporte e redes de energia. Na área de otimização de sistemas, os grafos resolvem problemas de caminho mais curto, fluxo máximo, alocação de recursos e otimização. Essas são apenas algumas das aplicações da teoria dos grafos que demonstra sua versatilidade e relevância em várias áreas.

![[Pasted image 20251024161301.png]]

A seguir, listamos alguns conceitos importantes sobre os grafos:

* Um grafo pode ter arestas paralelas, que são duas ou mais arestas associadas ao mesmo par de vértices. Em um dígrafo as arestas são paralelas somente quando elas apresentam a mesma direção.
* Um *loop* é uma aresta que conecta um vértice a ele mesmo.
* Um grafo simples é um grafo que não possui *loops* nem arestas paralelas. Os grafos das Figuras 1 e 2 são simples.
* Os vértices adjacentes são aqueles que são pontos finais da mesma aresta, e as arestas adjacentes são aquelas que compartilham um vértice comum. Na Figura 1, os vértices 3 e 6 são adjacentes e as arestas (3, 6) e (3, 4) também são adjacentes.
* O grau de um vértice é o número de arestas incidentes a ele. Na Figura 1, o grau do vértice 3 é igual a 3. Em dígrafos, temos os conceitos de grau de entrada e grau de saída. Assim, por exemplo, na Figura 2, o grau de entrada do vértice 3 é um e o de saída, dois. Um teorema importante sobre o grau dos vértices afirma que a soma dos graus de todos os vértices de um grafo é o dobro do número de arestas do grafo. Outro teorema sobre o grau dos vértices afirma que o número de vértices de grau ímpar em um grafo é sempre par.
* Um grafo regular é aquele em que todos os vértices possuem o mesmo grau. No caso dos dígrafos, eles têm que apresentar os mesmos graus de entrada e de saída. Os grafos das Figuras 1 e 2 não são regulares.
* Um vértice isolado é um vértice sem nenhuma aresta incidente. As Figuras 1 e 2 não têm vértices isolados.
* Um vértice pendente é um vértice com grau 1. Em um grafo orientado, a soma dos graus de entrada e saída deve ser igual a um. Nas Figuras 1 e 2, o vértice 6 é pendente.
* Um grafo nulo é um grafo sem arestas, onde todos os vértices são vértices isolados. As Figuras 1 e 2 não têm grafos nulos.
* Um grafo completo é aquele em que todos os vértices são adjacentes. Nesse caso, o número de arestas do grafo é igual a $\frac{n \times (n+1)}{2}$. Os grafos das Figuras 1 e 2 não são completos.
* Um grafo conexo é um grafo em que existe pelo menos um caminho entre todos os pares de vértices.
* O número de componentes de um grafo desconexo é o número de subgrafos conexos.
* Dois grafos são considerados isomorfos se houver uma correspondência um-para-um entre seus vértices e arestas, preservando as relações de incidência. A definição de grafos isomorfos ignora a nomenclatura dos vértices e o peso das arestas. Um problema complexo na área de grafos consiste em determinar se dois grafos quaisquer são isomórficos.
* O grafo complementar de um grafo G é formado pelos mesmos vértices de G, mas com as arestas que faltam em G para formar um grafo completo.
* Um grafo bipartido é um grafo não direcionado onde o conjunto de vértices pode ser dividido em dois subconjuntos, de forma que não existam arestas entre vértices do mesmo subconjunto.
* Um grafo g é considerado um subgrafo de um grafo G se todos os seus vértices e arestas estão contidos em G.
* A representação computacional dos dados pode ser feita com várias estruturas. As duas principais representações são a matriz de adjacências e a lista de adjacências. A matriz é utilizada para indicar se existe uma aresta entre dois vértices. As posições da matriz também podem armazenar o peso entre dois vértices. Por outro lado, a lista de adjacência armazena as conexões de cada vértice em uma lista encadeada. As Figuras 3 e 4 apresentam respectivamente a matriz e a lista de adjacências para o grafo não orientado mostrado na Figura 1. Por exemplo, na primeira linha da Figura 3 observamos que a coluna 1 tem o valor dois indicando que a aresta entre os vértices 0 e 1 tem peso dois. Por exemplo, na primeira célula da primeira linha da lista de adjacências da Figura 4 temos os números 1 e 2, indicando que o peso das arestas entre os vértices 0 e 1 é igual a dois.
![[Pasted image 20251024161415.png]]

- Caminhos em grafos são sequências de vértices e arestas que conectam dois ou mais vértices. Algoritmos como a busca em profundidade (do inglês, _depth first search_, DFS) e a busca em largura (do inglês, _breadth first search_, BFP) são usados para encontrar caminhos ou visitar todos os vértices de um grafo. A busca em grafos envolve percorrer o grafo para encontrar um determinado vértice, verificar a existência de um caminho entre dois vértices ou visitar todos os vértices de um grafo. Além da busca em profundidade e da busca em largura, existem outros algoritmos de busca, como a busca de Dijkstra, que encontra o caminho mais curto entre dois vértices em um grafo ponderado.
- Uma árvore em grafos é um subgrafo acíclico que conecta todos os vértices. Árvores geradoras mínimas são subgrafos que conectam todos os vértices com o menor custo possível. Algoritmos como Prim e Kruskal são utilizados para encontrar árvores geradoras mínimas.
- A conectividade em grafos refere-se à existência de caminhos entre vértices. É possível determinar se um grafo é conexo ou desconexo usando algoritmos de busca ou algoritmos de componentes fortemente conectados, como o algoritmo de Tarjan.
---

**TÉCNICA DE PROJETO: FORÇA BRUTA**

A técnica de força bruta é uma das formas mais simples de projetar algoritmos. Ela recebe esse nome devido à sua abordagem direta e exaustiva para resolver problemas, também chamada de busca exaustiva. Essa solução inicial e pouco elaborada é baseada diretamente no enunciado do problema, tornando-a fácil de ser aplicada e compreendida, mesmo por desenvolvedores menos experientes. A força bruta é aplicável a uma ampla variedade de problemas e pode ser especialmente útil quando o tamanho das entradas é pequeno e o tempo de execução não é uma prioridade. Embora exija maior esforço computacional, essa técnica pode ser a melhor opção em situações específicas e serve como ponto de partida para o desenvolvimento de soluções mais elaboradas e otimizadas.

A força bruta possui diversos exemplos de aplicação em algoritmos simples. Um deles é a pesquisa sequencial, onde uma lista de elementos é percorrida item a item para encontrar um valor específico. Outro exemplo é o método da bolha, um algoritmo de ordenação que compara repetidamente pares de elementos adjacentes e os troca se estiverem na ordem errada. Além disso, o cálculo recursivo dos números de Fibonacci pode ser considerado uma força bruta, pois recalcula os mesmos valores repetidamente, tornando-o ineficiente para valores grandes. A técnica de força bruta também é aplicada em problemas mais complexos, como no algoritmo de casamento de padrão para buscar sequências em uma string e na pesquisa exaustiva para o problema do caixeiro viajante, onde todas as possíveis rotas são avaliadas para encontrar a menor delas.

---

**TÉCNICA DE PROJETO: DIVISÃO E CONQUISTA**

A técnica conhecida como Divisão e Conquista, também referida como "dividir para conquistar" ou "_divide and conquer_" em inglês, é uma abordagem fundamental no projeto de algoritmos. Seu princípio essencial reside na ideia de que problemas complexos podem ser mais facilmente resolvidos quando são decompostos em partes menores e mais fáceis de resolver individualmente. A operacionalização dessa estratégia ocorre em três etapas: a divisão do problema em subproblemas menores e gerenciáveis, a resolução independente de cada subproblema e, por fim, a combinação das soluções obtidas para se alcançar a solução global.

Essa abordagem costuma resultar em soluções eficientes e elegantes, frequentemente implementadas de forma recursiva. Através da divisão do problema em subproblemas menores, é possível reduzir a complexidade geral da tarefa, o que torna a abordagem mais abrangente e aplicável em diferentes cenários. Além disso, algoritmos fundamentados na técnica de Divisão e Conquista são amplamente empregados em diversas áreas, desde tarefas de ordenação e busca em listas até problemas mais intrincados, como a determinação do máximo e mínimo em uma lista de elementos. A análise de complexidade desses algoritmos é normalmente conduzida através de equações de recorrência, levando em consideração o número de subproblemas gerados, o tamanho de cada um deles e o custo associado à operação de divisão.

Entre os exemplos paradigmáticos de algoritmos que empregam a técnica de Divisão e Conquista destacam-se a pesquisa binária, que eficientemente encontra um valor específico em uma lista ordenada; o Quicksort e o Mergesort, ambos algoritmos de ordenação com desempenho notável em uma série de situações; e a busca pelo máximo e mínimo em uma lista de elementos. Tais exemplos ilustram a versatilidade e a eficiência da abordagem de Divisão e Conquista no projeto de algoritmos, tornando-a uma ferramenta essencial para a resolução de problemas complexos de maneira sofisticada e otimizada.

---

**CONSIDERAÇÕES FINAIS DESTA SESSÃO DE ESTUDOS**

1. Introduzimos o projeto de algoritmos que consiste em uma das etapas do desenvolvimento de algoritmo. Essa etapa consiste na escolha da técnica adequada de projeto considerando critérios como custo, desempenho e corretude.
2. Revisamos os algoritmos em grafos, voltando com conceitos básicos e algoritmos tradicionais como as buscas em profundidade e largura.
3. Apresentamos as técnicas de força bruta e dividir e conquistar para o projeto de algoritmos. Para cada uma dessas técnicas, mostramos alguns exemplos clássicos existentes na literatura.

 Compreenda e retorne ao texto, vídeos e exercícios sempre que necessário. Até a próxima sessão de estudos.
**REFLEXÃO**

As técnicas de "força bruta" e "dividir e conquistar" na computação podem ser comparadas à vida humana. A "força bruta" reflete nossa tendência a enfrentar problemas com insistência e repetição, muitas vezes resultando em exaustão e resultados limitados. Em contraste, "dividir e conquistar" demonstra a sabedoria de abordar questões complexas dividindo-as em partes menores e gerenciáveis, possibilitando abordagens específicas para cada componente. Essas abordagens nos incentivam a questionar se estamos equilibrando a persistência com a inteligência estratégica para alcançar nossos objetivos de forma mais eficiente e significativa.