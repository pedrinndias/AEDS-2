## NESTA SESS√ÉO

Esta sess√£o de estudos apresenta e detalha mais tr√™s t√©cnicas para o projeto de algoritmos. As estrat√©gias apresentadas s√£o: **estrat√©gias gulosa (_greedy approach_), de retrocesso (_backtracking_)¬†e a programa√ß√£o din√¢mica.** Cada uma delas est√° detalhada a seguir.

---

**ESTRAT√âGIAS DE GULOSAS**

As estrat√©gias gulosas de projeto de algoritmos, tamb√©m conhecidas como algoritmos vorazes ou _greedy algorithms_ em ingl√™s, consistem em heur√≠sticas utilizadas para resolver problemas de otimiza√ß√£o. Em cada etapa do processo, essas abordagens fazem escolhas localmente √≥timas, com a expectativa de que, em conjunto, essas escolhas levem a uma solu√ß√£o global tamb√©m √≥tima. Embora essas t√©cnicas sejam atraentes devido √† simplicidade no projeto e implementa√ß√£o, n√£o oferecem garantia de encontrar a solu√ß√£o √≥tima em todos os casos. No entanto, s√£o amplamente aplicadas em situa√ß√µes em que a busca pela solu√ß√£o √≥tima √© impratic√°vel devido a limita√ß√µes de tempo ou recursos.

Um exemplo cl√°ssico da aplica√ß√£o das estrat√©gias gulosas √© o algoritmo guloso para o Problema do Caixeiro Viajante, que tem como objetivo determinar o menor caminho que percorre todos os v√©rtices de um grafo, retornando ao v√©rtice inicial. Encontrar a solu√ß√£o √≥tima exigiria testar todas as poss√≠veis rotas, levando a uma complexidade de tempo exponencial. Em contraste, o algoritmo guloso faz escolhas locais, selecionando em cada etapa o v√©rtice vizinho mais pr√≥ximo e ainda n√£o visitado. Embora n√£o garanta a solu√ß√£o √≥tima, sua simplicidade permite que seja executado em tempo razo√°vel, resultando em uma complexidade de tempo quadr√°tica. Al√©m do Problema do Caixeiro Viajante, outros exemplos de algoritmos gulosos incluem a solu√ß√£o gulosa para o problema da mochila, o Algoritmo de Prim para encontrar a √Årvore Geradora M√≠nima e o Algoritmo de Dijkstra para encontrar o caminho m√≠nimo em um grafo ponderado. Especificamente, os algoritmos de Prim e Dijkstra s√£o exemplos de estrat√©gias gulosas que garantem a solu√ß√£o √≥tima para os problemas que se prop√µem a resolver.

Uma caracter√≠stica marcante dos algoritmos gulosos √© sua abordagem sem retrocessos, o que significa que suas escolhas s√£o irrevog√°veis. Essa caracter√≠stica, aliada √† efici√™ncia em termos de tempo e recursos, torna os algoritmos gulosos uma op√ß√£o atraente para resolver problemas de otimiza√ß√£o em diversas √°reas. Embora possam n√£o alcan√ßar a solu√ß√£o global √≥tima, eles s√£o amplamente utilizados em aplica√ß√µes pr√°ticas, frequentemente produzindo solu√ß√µes suficientemente boas para atender a necessidades espec√≠ficas. Al√©m disso, esses algoritmos podem ser combinados com outras t√©cnicas de otimiza√ß√£o ou estrat√©gias de resolu√ß√£o de problemas para a obten√ß√£o de solu√ß√µes mais refinadas.

---

**ESTRAT√âGIAS DE RETROCESSO (_BACKTRACKING_)**

O _backtracking_ √© uma t√©cnica aplicada na resolu√ß√£o de problemas combinat√≥rios ou de otimiza√ß√£o, nos quais buscamos uma solu√ß√£o em um conjunto de possibilidades. Essa abordagem consiste em refinar a busca exaustiva, eliminando o custo de explorar solu√ß√µes descart√°veis. O processo inicia com uma solu√ß√£o parcial e, em seguida, testa cada poss√≠vel extens√£o dessa solu√ß√£o, retrocedendo quando uma extens√£o n√£o leva a uma solu√ß√£o v√°lida. Um exemplo de aplica√ß√£o do _backtracking_ √© mostrar os n√∫meros bin√°rios de quatro d√≠gitos que t√™m somente um d√≠gito igual a 1. A busca exaustiva testa todas as 16 combina√ß√µes poss√≠veis e o _backtracking_ retrocede quando uma solu√ß√£o parcial tem mais de uma ocorr√™ncia do d√≠gito um. Outro caso √© o Problema do Caixeiro Viajante, no qual um algoritmo com _backtracking_ evita testar solu√ß√µes parciais quando elas se tornam maiores que a solu√ß√£o m√≠nima conhecida, otimizando o processo. O _backtracking_ √© apropriado para problemas que possuem a propriedade de solu√ß√µes candidatas parciais, constru√≠das gradativamente e avaliadas a cada passo. √â importante que testes r√°pidos possam determinar se uma solu√ß√£o parcial pode ser completada at√© uma solu√ß√£o v√°lida.

O _backtracking_ √© realizado construindo solu√ß√µes adicionando um componente de cada vez e retrocedendo quando necess√°rio. Algumas de suas aplica√ß√µes incluem problemas de satisfa√ß√£o de restri√ß√µes (como palavras-cruzadas), _parsers_ e linguagens de programa√ß√£o l√≥gica. Entre suas vantagens est√£o a simplicidade para resolver problemas complexos e o suporte oferecido por linguagens de programa√ß√£o l√≥gica. Entretanto, ele pode exigir muita mem√≥ria para problemas grandes, e a redu√ß√£o de retrocessos se aproxima do custo da busca exaustiva. Por vezes, √© necess√°rio incorporar heur√≠sticas, com o custo da perda de garantia de otimalidade. Mesmo assim, o _backtracking_ √© uma t√©cnica poderosa e eficiente para resolver diversos problemas de otimiza√ß√£o e combinat√≥rios.

---

**PROGRAMA√á√ÉO DIN√ÇMICA**

A Programa√ß√£o Din√¢mica √© uma t√©cnica baseada em tabelas e amplamente aplicada na resolu√ß√£o de problemas combinat√≥rios ou de otimiza√ß√£o. Ela √© especialmente adequada quando a solu√ß√£o de um problema pode ser calculada a partir de solu√ß√µes anteriormente calculadas e memorizadas para subproblemas. Esses subproblemas s√£o sobrepostos e, juntos, comp√µem o problema original. A aplicabilidade da Programa√ß√£o Din√¢mica √© encontrada em problemas que possuem a propriedade de subestrutura √≥tima, onde a solu√ß√£o √≥tima para o problema global cont√©m solu√ß√µes √≥timas para seus subproblemas, e tamb√©m na superposi√ß√£o de subproblemas, onde um algoritmo reexamina o mesmo problema v√°rias vezes.

A efici√™ncia da Programa√ß√£o Din√¢mica √© influenciada pelo tamanho dos subproblemas. Se o somat√≥rio do tamanho dos subproblemas √© da ordem de ùöØ(n), √© prov√°vel que a complexidade seja polinomial. Por outro lado, se a divis√£o do problema de tamanho n resulta em n subproblemas de tamanho n-1 cada um, a complexidade √© prov√°vel que seja exponencial. Um exemplo cl√°ssico de aplica√ß√£o da Programa√ß√£o Din√¢mica √© a otimiza√ß√£o do c√°lculo do n√∫mero de Fibonacci de forma recursiva, onde a t√©cnica evita o estouro do n√∫mero de chamadas ao recalcular valores conhecidos, tornando o algoritmo mais eficiente. Ao usar a programa√ß√£o din√¢mica, √© poss√≠vel reduzir drasticamente o tempo de execu√ß√£o de algoritmos que, de outra forma, seriam invi√°veis de serem resolvidos de maneira eficiente.

---

**CONSIDERA√á√ïES FINAIS DESTA SESS√ÉO DE ESTUDOS**

1. Discutimos as estrat√©gias gulosas de projeto de algoritmos. Elas consistem em uma classe de abordagens heur√≠sticas que fazem escolhas localmente √≥timas em cada etapa, na esperan√ßa de alcan√ßar uma solu√ß√£o global √≥tima. Embora n√£o garantam a solu√ß√£o ideal, esses algoritmos s√£o amplamente aplicados em problemas de otimiza√ß√£o onde a busca pela solu√ß√£o √≥tima √© impratic√°vel devido a restri√ß√µes de tempo ou recursos.
2. Apresentamos a t√©cnica de _backtracking_ que consiste em refinar a busca exaustiva, eliminando solu√ß√µes descart√°veis, retrocedendo quando necess√°rio. Ele √© usado em problemas que possuem solu√ß√µes candidatas parciais e √© aplicado em diversas √°reas, como problemas de satisfa√ß√£o de restri√ß√µes e o Problema do Caixeiro Viajante. Embora seja poderoso e eficiente, pode exigir muita mem√≥ria e n√£o garante a solu√ß√£o √≥tima para todos os casos.
3. Mostramos a programa√ß√£o din√¢mica, uma t√©cnica baseada em solucionar subproblemas sobrepostos, armazenando seus resultados em tabelas para evitar rec√°lculos.

Compreenda e retorne ao texto, v√≠deos e exerc√≠cios sempre que necess√°rio. At√© a pr√≥xima sess√£o de estudos.

**REFLEX√ÉO**

As t√©cnicas de projeto de algoritmos apresentadas nesta sess√£o de estudos podem ser levadas para nossa vida cotidiana e profissional, onde enfrentamos escolhas e desafios di√°rios. A estrat√©gia gulosa nos ensina a tomar decis√µes que parecem ben√©ficas a curto prazo, buscando solu√ß√µes √≥timas no momento presente, enquanto o retrocesso nos relembra que √© preciso aceitar e aprender com as escolhas que n√£o nos levaram aos resultados desejados, possibilitando ajustes de rumo. A programa√ß√£o din√¢mica nos mostra que ao reconhecer e reutilizar li√ß√µes do passado, superando desafios e construindo sobre bases s√≥lidas, alcan√ßamos progresso e efici√™ncia duradouros em nossa jornada pessoal e profissional.