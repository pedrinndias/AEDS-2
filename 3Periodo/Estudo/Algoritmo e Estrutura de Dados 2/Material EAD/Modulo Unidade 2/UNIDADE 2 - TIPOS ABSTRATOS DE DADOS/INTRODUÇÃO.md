
## NESTA SESSÃO

A Unidade I apresentou as *Collections* existentes em C#. Conhecê-las é fundamental, contudo, o bom desenvolvedor domina o funcionamento das mesmas para usá-las de uma forma eficaz. O restante desta unidade aborda o funcionamento básico das estruturas de listas, árvores binárias e tabelas *hash*. As listas podem ser lineares ou flexíveis. O `ArrayList` e a `List<T>` são exemplos de listas lineares em C# e a `LinkedList<T>`, de flexível. Uma lista linear tem um *array* e um contador para gerenciar sua quantidade de elementos. Quando o contador atinge a capacidade do *array*, a implementação da lista proíbe novas inserções ou aumenta essa capacidade de armazenamento. Proibir inserções é uma estratégia mais simples de se implementar. A segunda estratégia é usada, por exemplo, nas classes `ArrayList` e `List<T>` do C#. Nessas classes, quando atingimos a capacidade de armazenamento do *array*, o C# cria um novo *array* (maior que o atual), copia todos os elementos do *array* antigo para o novo e desaloca o antigo. Por outro lado, uma lista flexível cresce sob demanda. Cada posição da lista flexível é composta por uma célula contendo um par de valor/referência. O valor corresponde ao elemento existente na referida posição e a referência é necessária para acessarmos a outra célula. A Figura 1 mostra um exemplo de lista flexível em que temos uma referência inicial chamada "Primeiro" (seta preta) que aponta para uma primeira célula da lista contendo o número 1. Essa célula aponta para outra (a do número 2) e, assim, sucessivamente. Na Figura 1, observamos que as posições da lista flexível ficam "espalhadas". Na lista linear, o armazenamento na memória é sequencial como em qualquer *array*.

![[Pasted image 20251024173349.png]]

Comparando as listas lineares e flexíveis, identificamos que cada uma delas tem suas vantagens. O desenvolvedor deve conhecer tais vantagens para decidir quando utilizar cada uma delas. Uma vantagem da lista linear é sua simplicidade de implementação dado que ela apenas gerencia um _array_ e seu contador de elementos. Outra vantagem é seu custo reduzido para encontrar um elemento em uma dada posição. Essa operação consiste apenas no comando _array[posição]_. A terceira vantagem da estrutura linear em relação à flexível é seu tempo de acesso. Isso porque na linear, os elementos estão alocados sequencialmente enquanto na flexível, "espalhados" pela memória. Na flexível, estando em uma posição, precisamos verificar qual é a referência da próxima para, assim, alcançá-la. Na linear, se a capacidade do _array_ ainda não foi alcançada, basta caminharmos para a próxima posição de memória. A quarta vantagem da lista linear é o espaço de memória consumido. Nessa estrutura, cada posição do _array_ armazena um elemento. Na flexível, cada célula demanda um espaço para o elemento e outro para a referência. Por outro lado, a vantagem da lista flexível é a facilidade de aumentarmos e reduzirmos seu tamanho. A lista flexível é indicada quando o tamanho da mesma é imprevisível ou mais variante. É interessante destacar que a lista flexível é mais elegante que a linear, exigindo que o programador domine o conceito de referência.

Neste ponto é interessante destacar que as pilhas e filas são exemplos de listas em que as operações de inserção e remoção têm suas especificidades para garantir as propriedades das pilhas e filas. Na pilha, o primeiro elemento que entra é o último a sair e o último que entra é o primeiro a sair. Na fila, o primeiro elemento que entra é o primeiro a sair. Podemos implementar tanto as filas como as pilhas de forma linear ou flexível, bastando considerar as propriedades de cada uma dessas estruturas na implementação linear ou flexível das listas.

O segundo tipo de estrutura de dados abordado na Unidade II são as árvores binárias. Apesar de tradicional e bastante utilizada na prática, não temos essa implementação de forma nativa na linguagem C#. Tais árvores são estruturas formadas por um conjunto finito de nós (vértices) conectados por arestas. A Figura 2 ilustra um exemplo de árvore em que os nós são as "bolinhas" e as arestas, os "tracinhos". As árvores são um exemplo de estrutura flexível em que os elementos são alocados sob demanda. As operações básicas (inserir, remover e pesquisar) podem ser executadas de forma eficiente quando comparadas com uma lista linear ou flexível. Em uma árvore com **n** nós, podemos executar tais operações com custo **θ(lg n)** no pior caso. Podemos ler o operador **θ** como aproximadamente ou proporcionalmente. Logo, o fato do custo em uma árvore poder ser **θ(lg n**) significa que executamos tais operações fazendo aproximadamente **lg n** comparações entre elementos da árvore. **Lg** é o logaritmo na base dois de **n**. Por exemplo, se uma árvore tiver 1024 nós, pesquisaremos um elemento nessa estrutura fazendo aproximadamente 10 comparações no pior caso. Isso porque o logaritmo na base dois de 1024 é dez.
![[Pasted image 20251024174330.png]]

A terceira estrutura de dados abordada nesta unidade são as tabelas _hash_. As implementações dessa estrutura em C# são a _Hashtable_ e o _Dictionary<TKey, TValue>_. Usando uma tabela _hash_, podemos acessar valores com custo **θ(1)**, ou seja, fazendo aproximadamente uma comparação entre elementos da tabela. Uma tabela _hash_ consiste em um _array_ e uma função de transformação. Essa função recebe como entrada um valor a ser inserido/pesquisado/removido em nossa estrutura e retorna como saída a posição desse valor na tabela (_array_), fazendo um mapeamento do tipo chave/valor em que cada valor tem sua chave ou posição no _array_. Na verdade, a função de transformação faz o mapeamento de um subconjunto de valores em uma mesma posição da tabela. Assim, quando inserirmos dois valores com a mesma chave, temos uma colisão. O principal desafio no projeto de uma tabela _hash_ são essas colisões. Destaca-se ainda que diferente das estruturas _Hashtable_ e _Dictionary_ do C#, a teoria de tabelas _hash_ considera que as chave são obrigatoriamente números inteiros. 

Aprofunde seus conceitos envolvendo listas, árvores binárias e tabelas _hash_ nas próximas sessões de estudo desta Unidade.

