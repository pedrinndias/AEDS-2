## NESTA SESSÃO

As tabelas _hash_ são estruturas formadas por um _array_ e uma função de transformação. Essa função recebe como entrada um valor a ser inserido, pesquisado ou removido em nossa estrutura e retorna como saída a posição desse valor na tabela (_array_ ), fazendo um mapeamento do tipo chave/valor em que cada valor tem sua chave (posição no _array_ ). A principal vantagem dessa estrutura de dados é que podemos pesquisar por valores com custo **θ(1)**, ou seja, fazendo aproximadamente uma comparação entre elementos da tabela. Entretanto, esse custo depende do projeto da nossa tabela. Isso porque, n a verdade, a função de transformação normalmente faz o mapeamento de um subconjunto de valores em uma mesma posição da tabela. Assim, quando inserirmos dois valores com a mesma chave, temos uma colisão. O principal desafio no projeto de uma tabela _hash_ é o tratamento dessas colisões, denominadas colisões primárias.

A literatura apresenta três técnicas básicas para tratamento das colisões: _Hash_ direto com área de reserva (_overflow_), _hash_ direto com _rehash_ e _hash_ indireto com lista flexível simples. A Figura 1 ilustra cada uma dessas tabelas. As duas primeiras técnicas inserem os elementos que sofreram colisão dentro da própria tabela. A terceira, os insere em uma estrutura auxiliar. A primeira técnica assume que o _array_ tem uma área de reserva na qual colocamos apenas os elementos que sofreram colisão. A Figura 1a ilustra o primeiro tipo de tabela em que a função de transformação sempre retorna chaves correspondendo às posições brancas. Nesse caso, a inserção de um elemento cuja chave corresponde à uma posição ocupada acontece na área de reserva, posições cinzas. A segunda técnica usa duas funções de transformação, assim, ao inserirmos um elemento, se primeira função retornar uma chave que corresponde à uma posição "ocupada", teremos outra chance de inserção através da segunda função de transformação. A Figura 1b ilustra o segundo tipo de tabela onde as duas funções mapeiam os elementos em quaisquer posição da tabela. A terceira técnica assume a existência de uma lista flexível para cada posição da tabela. Nesse caso, a inserção de um elemento cuja chave corresponde à uma posição ocupada acontece na lista da sua respectiva posição. A Figura 1c mostra o terceiro tipo de tabela. A literatura apresenta outras formas de tratamento de colisões, por exemplo, combinando as três técnicas apresentadas ou substituindo as listas flexíveis da última técnica por árvores binárias balanceadas.

![[Pasted image 20251024174446.png]]

As classes _Hashtable_  e _Dictionary<TKey, TValue>_ implementam a estrutura de tabela _hash_ em C#. A principal diferença entre a teoria de tabelas _hash_ e tais classes em C# é que a teoria considera que as chave são obrigatoriamente números inteiros.